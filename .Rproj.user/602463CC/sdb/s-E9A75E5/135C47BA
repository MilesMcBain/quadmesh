{
    "collab_server" : "",
    "contents" : "\n.mkq3d <- function() {\n  structure(list(vb = NULL, ib = NULL, primitivetype = \"quad\",\n                 material = list(), normals = NULL, texcoords = NULL), .Names = c(\"vb\",\n                                                                                  \"ib\", \"primitivetype\", \"material\", \"normals\", \"texcoords\"), class = c(\"mesh3d\",\n                                                                                                                                                        \"shape3d\"))\n\n  }\n\n#' @importFrom raster xmin xmax ymin ymax\nedgesXY <- function(x) {\n  ## report to Hijmans 2015-11-06\n  #extract(r, expand.grid(c(xmin(r), xmax(r)), c(ymin(r), ymax(r))), method = \"bilinear\")\n  #[1]   NA   NA 99.5   NA\n  ## remove this eps fudge once bilinear works\n  eps <- sqrt(.Machine$double.eps)\n  as.matrix(expand.grid(seq(xmin(x), xmax(x) -eps, length = ncol(x) + 1),\n                        seq(ymax(x), ymin(x) + eps, length = nrow(x) + 1)\n  ))\n}\n\n#' @importFrom utils head tail\nprs <- function(x) {\n  cbind(head(x, -1), tail(x, -1))\n}\n\np4 <- function(xp, nc) {\n  (xp + c(0, 0, rep(nc, 2)))[c(1, 2, 4, 3)]\n}\n\n\n#' Create a quad-type mesh for use in rgl\n#'\n#' Convert a \\code{\\link[raster]{raster}} to a \\code{\\link[rgl]{mesh3d}} quadrangle mesh.\n#' @param x raster object for mesh structure\n#' @param z raster object for height values\n#' @param na.rm remove quads where missing values?\n#' @return mesh3d\n#' @export\n#' @importFrom raster extract extent values\n#' @importFrom dplyr  bind_rows  distinct  group_by  inner_join  mutate row_number transmute\n#' library(raster)\n#' data(volcano)\n#' r <- setExtent(raster(volcano), extent(0, 100, 0, 200))\n#' qm <- quadmesh(r)f\nquadmesh <- function(x, z = x, na.rm = FALSE) {\n  x <- x[[1]]  ## just the oneth raster for now\n  ##exy <- as.matrix(expand.grid(edges(x), edges(x, \"y\")))\n  exy <- edgesXY(x)\n  ind <- apply(prs(seq(ncol(x) + 1)), 1, p4, nc = ncol(x) + 1)\n\n\n  ## all face indexes\n  ind0 <- as.vector(ind) +\n    rep(seq(0, length = nrow(x), by = ncol(x) + 1), each = 4 * ncol(x))\n\n\n  ## need to consider normalizing vertices here\n  if (na.rm) {\n    ind1 <- matrix(ind0, nrow = 4)\n    ind0 <- ind1[,!is.na(values(x))]\n  }\n  ob <- .mkq3d()\n\n  if (!is.null(z)) z <- extract(z, exy, method = \"bilinear\") else z <- 0\n  ob$vb <- t(cbind(exy, z, 1))\n  ob$ib <- matrix(ind0, nrow = 4)\n  ob\n}\n",
    "created" : 1465663967672.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3894626073",
    "id" : "135C47BA",
    "lastKnownWriteTime" : 1465668904,
    "last_content_update" : 1465668904177,
    "path" : "D:/twotera/GIT/quadmesh/R/quadmesh.r",
    "project_path" : "R/quadmesh.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}